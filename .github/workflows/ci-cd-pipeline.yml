name: CI/CD Pipeline (Build -> Deploy)

on:
  push:
    tags:
      - 'v*' # Chạy khi đánh tag

permissions:
  contents: read
  packages: write # Cần quyền write để push ảnh, read để pull ảnh

jobs:
  # --- GIAI ĐOẠN 1: BUILD & PUSH (Chạy trên Github Cloud) ---
  build-and-push:
    name: Build & Push Docker
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Get Version
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Build Gateway
      - name: Build & Push Gateway
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_NAME=ghcr.io/$OWNER_LC/landslide-gateway
          TAG=${{ steps.get_version.outputs.VERSION }}
          
          cd gateway
          docker build -t $IMAGE_NAME:$TAG -t $IMAGE_NAME:latest .
          docker push $IMAGE_NAME:$TAG
          docker push $IMAGE_NAME:latest

      # Build Server
      - name: Build & Push Server
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_NAME=ghcr.io/$OWNER_LC/landslide-server
          TAG=${{ steps.get_version.outputs.VERSION }}
          
          cd server
          docker build -t $IMAGE_NAME:$TAG -t $IMAGE_NAME:latest .
          docker push $IMAGE_NAME:$TAG
          docker push $IMAGE_NAME:latest

  # --- GIAI ĐOẠN 2: DEPLOY (Chạy trên Server thật) ---
  
  # Job 1: Dọn dẹp môi trường (Chạy riêng biệt để đảm bảo sạch sẽ)
  cleanup:
    name: Cleanup Workspace
    needs: build-and-push
    runs-on: self-hosted
    steps:
      - name: Force Clean Workspace via Docker
        run: |
          echo "Cleaning up workspace using Docker (to bypass permission issues)..."
          # Đường dẫn tới thư mục cha của workspace
          WORK_DIR="$HOME/actions-runner/_work/landslide-monitoring"
          TARGET_DIR="landslide-monitoring"
          
          # Sử dụng Docker alpine để xóa file với quyền root
          # Mount thư mục cha vào /work bên trong container
          docker run --rm -v "$WORK_DIR:/work" alpine sh -c "rm -rf /work/$TARGET_DIR"
          
          echo "Workspace cleaned via Docker."
          
          # Đảm bảo thư mục tồn tại và thuộc quyền user hiện tại
          mkdir -p "$WORK_DIR/$TARGET_DIR"
          # Không dùng sudo chown vì không có quyền sudo, nhưng user hiện tại đã tạo thư mục nên có quyền sở hữu
          
  # Job 2: Deploy ứng dụng
  deploy:
    name: Deploy to Server
    needs: cleanup # Chờ dọn dẹp xong mới chạy
    runs-on: self-hosted
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4


      - name: Get Version
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy Steps
        run: |
          echo "Starting deploy version ${{ steps.get_version.outputs.VERSION }}..."
          
          # --- FIX PERMISSIONS (VẤN ĐỀ 1) ---
          # Lấy lại quyền sở hữu thư mục hiện tại để tránh lỗi permission denied khi checkout/clean
          echo "Fixing permissions..."
          sudo chown -R $USER:$USER . || echo "Warning: Could not chown, trying to proceed..."
          
          # --- 1. SERVER APP ---
          cd server
          export APP_VERSION=${{ steps.get_version.outputs.VERSION }}
          
          # Đặt tên project cố định để tránh tạo ra các container mồ côi
          export COMPOSE_PROJECT_NAME=landslide_server

          # --- DỌN DẸP CONTAINER CŨ (VẤN ĐỀ 2) ---
          echo "Cleaning up old containers..."
          # Down toàn bộ service cũ để tránh conflict tên
          docker-compose down --remove-orphans || true
          
          # Tải image mới nhất
          docker-compose pull
          
          # Up container
          echo "Starting services..."
          docker-compose up -d --force-recreate
          
          # Kiểm tra ngay lập tức xem container có chạy không
          echo "Checking container status:"
          docker-compose ps
          
          # Đợi Kafka khởi động
          echo "Waiting for Kafka to be ready..."
          sleep 15
          
          # Tạo topic 'landslide_data' (nếu chưa có)
          echo "Creating Kafka topic 'landslide_data'..."
          docker exec kafka kafka-topics --create --if-not-exists --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic landslide_data || echo "Topic creation failed (might already exist or Kafka not ready)"
          
          # Restart Spark
          echo "Restarting Spark..."
          docker restart spark-master
          sleep 10
          
          # Submit Spark job và ghi log vào file trong container
          echo "Submitting Spark job with logging..."
          docker exec spark-master bash -c "nohup /opt/spark/bin/spark-submit \
            --master spark://spark-master:7077 \
            --packages org.apache.spark:spark-sql-kafka-0-10_2.12:3.5.0 \
            /app/spark_jobs/processor.py > /tmp/spark_job.log 2>&1 &"
          
          # Đợi job khởi động và xử lý dữ liệu (tăng lên 60s để có ít nhất 1 batch)
          echo "Waiting 30s for Spark job to initialize..."
          sleep 30
          
          # Gửi dữ liệu mẫu vào Kafka để verify (phòng trường hợp sensor chưa kết nối)
          echo "Sending test data to Kafka..."
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          # Gửi 5 message mẫu
          for i in {1..5}; do
             docker exec kafka kafka-console-producer --broker-list localhost:9092 --topic landslide_data <<EOF
          {"timestamp": "${TIMESTAMP}", "sensor_id": "test_rain_$i", "sensor_type": "rain", "value": {"intensity": 25.5, "acceleration": {"z": 0.0}, "water_level": 0.0, "longitude": 0.0}}
          {"timestamp": "${TIMESTAMP}", "sensor_id": "test_imu_$i", "sensor_type": "imu", "value": {"intensity": 0.0, "acceleration": {"z": 9.8}, "water_level": 0.0, "longitude": 0.0}}
          EOF
             sleep 2
          done
          
          echo "Waiting another 30s for Spark to process test data..."
          sleep 30
          
          # Lưu bảng dữ liệu ASCII từ Spark vào file
          # Lưu vào thư mục cố định trong home directory để dễ truy cập
          LOG_DIR="$HOME/spark_logs"
          mkdir -p "$LOG_DIR"
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          LOG_FILE="$LOG_DIR/spark_data_${TIMESTAMP}.log"
          
          echo "Saving Spark processing data to file: $LOG_FILE"
          
          {
            echo "=========================================="
            echo "Spark Processing Data (ASCII Table)"
            echo "Timestamp: $(date)"
            echo "Version: ${{ steps.get_version.outputs.VERSION }}"
            echo "=========================================="
            echo ""
            
            echo "--- Spark Job Output (from /tmp/spark_job.log) ---"
            # Đọc log trực tiếp từ file mà Spark job đang ghi
            docker exec spark-master cat /tmp/spark_job.log 2>/dev/null || echo "Job log file not found yet"
            echo ""
            
            echo "--- Recent Spark Master Logs (last 200 lines) ---"
            docker logs spark-master --tail 200 2>&1
            echo ""
            
            echo "--- Recent Spark Worker Logs (last 200 lines) ---"
            docker logs spark-worker --tail 200 2>&1 || echo "Worker logs not available"
            echo ""
            
            echo "=========================================="
            echo "End of log"
            echo "=========================================="
          } > "$LOG_FILE"
          
          # Kiểm tra file đã được tạo chưa
          if [ -f "$LOG_FILE" ]; then
            echo "✓ Spark data saved to: $LOG_FILE"
            echo "✓ File size: $(du -h "$LOG_FILE" | cut -f1)"
            echo "✓ Full path: $(realpath "$LOG_FILE")"
            ls -lh "$LOG_FILE"
          else
            echo "✗ ERROR: File was not created at $LOG_FILE"
            echo "Current directory: $(pwd)"
            echo "Log directory exists: $([ -d "$LOG_DIR" ] && echo 'Yes' || echo 'No')"
          fi
            
          # --- 2. GATEWAY (Nếu chạy chung server) ---
          echo "Deploying Gateway..."
          cd ../gateway
          
          # Đặt tên project cho gateway
          export COMPOSE_PROJECT_NAME=landslide_gateway
          
          # Dọn dẹp gateway cũ
          docker-compose down --remove-orphans || true
          
          # Pull và Up lại
          docker-compose pull
          docker-compose up -d --force-recreate
          
          echo "Checking Gateway status:"
          docker-compose ps

          echo "All Systems Deployed Successfully!"

